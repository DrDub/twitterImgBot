#!/usr/bin/python

import os
import configparser
import tweepy
import glob
import random
import datetime


class Tweet():

    def media(self, source_folder, dont_tweet_file, log_file,
              allow_repeat_after):
        media_list = glob.glob(source_folder + "*")
        selected_media = random.choice(media_list)
        if (
            Tweet.is_already_tweeted(log_file, selected_media, allow_repeat_after)
            or Tweet.is_banned(dont_tweet_file, selected_media)
            ):
                self.media(source_folder, dont_tweet_file, log_file,
                           allow_repeat_after)
        return(selected_media)

    @staticmethod
    def is_already_tweeted(log_file, image, allow_repeat_after):
        if os.path.isfile(log_file):
            return False
        try:
            already_tweeted = open(log_file, 'r').readlines()[allow_repeat_after]
        except IndexError:
            already_tweeted = open(log_file, 'r').readlines()
        for element in already_tweeted:
            if element.split('\t')[1] == image:
                return True

    @staticmethod
    def is_banned(banned_list, selected_media):
        with open(banned_list, 'r') as banned:
            if selected_media in banned:
                return True

    def text(self, text):
        return(text)

def create_tweet(log_file, source_folder, dont_tweet_file, allow_repeat_after,
                 api, text=None, reply_id=None):
    """Creates a tweet, full with text, media and reply_id"""
    tweet = Tweet()
    tweet_text = tweet.text(text)
    tweet_media = tweet.media(source_folder, dont_tweet_file, log_file,
                              allow_repeat_after)
    api.update_with_media(
        filename=tweet_media,
        status=tweet_text,
        in_reply_to_status_id=reply_id)
    with open(log_file, 'a') as log:
        log.write(str(datetime.datetime.now()) + '\t' + str(tweet_media) +
                  '\t' + str(reply_id) + '\n')


def check_orders(master_account, bot_account,
                 source_folder, dont_tweet_file, log_file,
                 ban_command, request_command, request_answers,
                 request_to_third_answers, allow_repeat_after, api):
    """ Beware, here be dragons
        Checks for orders from the master accounts. DMs are more private,
        but they give me 403 error now. I'll try again tomorrow
        I'll comment everything extensivily 'cause it is a mess"""

    # we first set and expiration time. we dont wanna listen to old orders
    for element in api.user_timeline(master_account)[0:3]:
        # only check orders in your last three tweets
        if is_recent(element, 2) and not already_answered(element, log_file):
            if element.text.startswith(ban_command):
                last_tweet = api.user_timeline()[0].id  # get last tweet id
                api.destroy_status(last_tweet)  # destroy it
                # gets last line in log and strips to just have the path
                last_media = open(log_file, 'r').readlines()[-1]
                last_media = last_media.split('\t')[1]
                # add that media to our don't tweet list
                with open(dont_tweet_file_file, 'a') as banned:
                    banned.write(str(last_media) + '\n')
    for element in api.search(bot_account):
        if is_recent(element, 5) and not already_answered(element, log_file):
            if element.text.lower().startswith(request_command.lower()):
                user_name = element.user.screen_name
                reply_id = element.id
                if is_request_to_third(element.text):
                    user_to_send = ('@' + request_to_whom(element.text))
                    text = (user_to_send + ' ' +
                            random.choice(request_to_third_answers) +
                            ' @' + user_name)
                else:
                    answer = random.choice(request_answers)
                    text = ('@' + user_name + ' ' + answer)
                create_tweet(log_file, source_folder, dont_tweet_file,
                             allow_repeat_after, api, text, reply_id)


def already_answered(tweet, log_file):
    with open(log_file, 'r') as log:
        for line in log:
            if str(tweet.id) in line:
                return(True)


def is_request_to_third(tweet):
    if "to @" in tweet.lower():
        return(True)
    else:
        return(False)


def request_to_whom(tweet):
    after_to_at = tweet.partition('to @')[2]
    user_to_send_to = after_to_at.partition(' ')[0]
    return(user_to_send_to)


def is_recent(tweet, time_in_minutes):
    expiration_time = datetime.timedelta(minutes=time_in_minutes)
    order_date = tweet.created_at
    time_since_order = datetime.datetime.utcnow() - order_date
    if time_since_order < expiration_time:
        return True
    else:
        return False

def run():
    """Sets directory so we can read settings.txt.
       See if chance is met
       Authenticate to twitter
       Pass relevant arguments to twitt_it
       """
    # see where is the script is located...
    abspath = os.path.abspath(__file__)
    dname = os.path.dirname(abspath)
    # read configs from file
    config = configparser.ConfigParser()
    config.read(dname + '/bot_settings.ini')
    twitter_config = config['Twitter']
    api_key = twitter_config['api_key']
    secret_key = twitter_config['secret_key']
    token = twitter_config['token']
    secret_token = twitter_config['secret_token']
    app_config = config['App']
    source_folder = app_config['image_folder']
    master_account = app_config['master_account']
    bot_account = app_config['bot_account']
    log_file = app_config['log_file']
    dont_tweet_file = app_config['dont_tweet_file']
    allow_repeat_after = int(app_config['allow_repeat_after'])
    orders_config = config['Orders']
    ban_command = orders_config['ban_command']
    request_command = orders_config['request_command']
    answers_config = config['Texts']
    request_answers = answers_config['request_answers'].split('\n')
    request_to_third_answers = answers_config['request_to_third_answers'].split('\n')

    auth = tweepy.OAuthHandler(api_key, secret_key)
    auth.set_access_token(token, secret_token)
    api = tweepy.API(auth)

    check_orders(master_account, bot_account, source_folder, dont_tweet_file,
                 log_file, ban_command, request_command, request_answers,
                 request_to_third_answers, allow_repeat_after, api)

    chance = int(app_config['execution_chance'])
    if random.randint(0, 99) < chance:
        # only if chance is met

        create_tweet(log_file, source_folder, dont_tweet_file,
                     allow_repeat_after, api)

if __name__ == '__main__':
    run()
